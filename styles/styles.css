* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
:root {
  /* random shit */
  --outline-edges-theme: 0.04rem solid #8332ac;
  /* --boxshadow: 0.1rem 0.1rem 1rem black; */
  /* bg colors */
  --body-bg-color: rgba(187, 119, 154, 0.5);
  --overlay-color: rgba(45, 35, 46, 0.85);
  /* fonts and paragraph related */
  --font-family-not-header: "Gayathri", sans-serif;
  --font-color: white;
  --overall-line-height: 1.4;
  --letterspacing: 0.15rem;
  /*--------- unknown custom properties ---------*/
  --menu-speed: 0.75s;
  /* layout handling */
  --section-fullheight: 100vh;
}
body {
  /* NOTE Quite la estupidez de las variantes */
  font-family: "Gayathri", sans-serif;
  line-height: 1.4;
}
.logo {
  width: 10vw;
  /*NOTE The positioning is done relative to the first relatively (or absolutely) positioned parent element. In the case when there is no positioned parent element, it will be positioned related directly to the HTML element (the page itself).  */
  position: absolute;
  /*NOTE Positioning properties like bellow create a gap towards the left between the parent (body) and itself (logo) */
  left: 87vw;
  top: 2vh;
  z-index: 2;
}
/* This is the section where the main image is  */
.shakepic {
  /* NOTE quite la estupidez de las variantes */
  position: absolute;
  height: 100vh;
  z-index: 0;
  width: 100vw;
  /* HACK width property fixes cross-scrolling */
}
.container {
  width: 100vw;
  margin: auto;
  overflow: hidden;
  position: relative;
  z-index: 1;
  /* NOTE quite la estupidez de las variantes */
  background: rgba(187, 119, 154, 0.5);
  box-shadow: inset 0 -2rem 1rem -1rem #c58daa,
    inset 0 -14rem 10rem -10rem #c58daa;
  /*  HACK This Box Shadow is what makes a degraded between first and second sections */
}

.showcase {
  /* NOTE quite la estupidez de las variantes */
  color: white;
  height: 100vh;
  /*  REVIEW removing showcase's position may cause errors position: relative; */
}
.showcase .showcase-inner {
  align-items: center;
  text-align: center;
  height: 100vh;
  letter-spacing: 0.15rem;
  padding: 19vh 14vw 0 14vw;
}
.showcase h1 {
  font-size: 2.2rem;
}
.showcase p {
  letter-spacing: 0.15rem;
  padding-top: 4vh;
  text-align: justify;
}
/* Styling for the BUTTON */
.btn {
  display: inline-block;
  font-weight: bold;
  border: none;
  /* NOTE quite estupidez de variantes */
  background: rgba(187, 119, 154, 0.5);
  color: white;
  padding: 5vh 9vw;
  margin-top: 14vh;
  text-decoration: none;
  border-radius: 8%;
  /* NOTE quite estupidez de variantes */
  border: 0.04rem solid #8332ac;
  /*NOTE el 1er valor es el eje horizontal, el 2do el vertical, el 3ro el blur, el 4to alarga las sombra hacia todas direcciones */
  /*HACK en esta propiedad los dos primeros valores de sombras proyectan sombra hacia abajo creando un efecto de blur y oscuridad mas marcados y que no se logra con un solo value de sombra */
  /*HACK tambien se puede usar 3 valores inset lo que logra 3 colores distintos dentro, hay que jugar bastante con el 4 value de las sombras para lograr esto */
  box-shadow: 0 10px 10px rgba(0, 0, 0, 0.19), 0 19px 19px rgba(0, 0, 0, 0.23),
    inset 0 -15px 28px #a469c2;
}
/* Start of styles for landpage button */
/* NOTE agregue pseudo clases para el boton "READ MORE" del landpage, utilize por primera vez transform property */
.btn:link {
  color: white;
}
.btn:visited {
  color: rgb(247, 48, 81);
}
.btn:hover {
  /* NOTE Recordemos que en mobiles el hover no renderiza, en mobiles el hover se acciona al hacer "tap" */
  background: rgba(157, 119, 154, 0.5);
}
.btn:active {
  /* NOTE La pseudo clase :active fue a la que mas propiedades se le dio, incluyendo Transform */
  border: 0.04rem solid white;
  background: #f1a5b7;
  opacity: 0.65;
  box-shadow: 0 10px 10px rgba(0, 0, 0, 0.59), 0 19px 19px rgba(0, 0, 0, 0.23),
    inset 0 -15px 28px #be4a66;
  transform: scale(1.06);
}
/* End of styles for landpage button */

/* Second section, just bellow landpage Start First Part*/
/* NOTE En esta seccion se explica mediante comments como esta compuesta la seccion de los planetas*/
.side-bar {
  /* position: relative; */
  /* z-index: -1; */
  width: 18vw;
  height: 13vh;
  margin-right: 5vw;
  border-radius: 50%;
  float: right;
  background: linear-gradient(
    130deg,
    rgba(131, 58, 180, 1) 0%,
    rgba(253, 228, 29, 1) 50%,
    rgba(252, 176, 69, 1) 100%
  );
  box-shadow: inset 10px -6px 10px 3px rgba(0, 0, 0, 0.23),
    inset -1px 1px 10px 0.5px rgb(250, 249, 247);
}

.content {
  width: 35vw;
  height: 20vh;
  float: right;
  /* Sin float este elemento vuelve al flow normal como su hermano .side-bar, el cual es un bloque que es parte ya del flow normal como hijo de .upper-main, el div bloque de .side.bar que ocupa todo el ancho del viewport no permite otros elementos a la par, por eso este div se coloca justo por debajo al remover float */
  border-radius: 50%;
  background: linear-gradient(
    205deg,
    rgba(131, 58, 180, 1) 0%,
    rgba(253, 29, 29, 1) 50%,
    rgba(252, 176, 69, 1) 100%
  );
  margin: -2rem 1rem 0 0;
  box-shadow: -10px 6px 10px 3px rgba(0, 0, 0, 0.23),
    inset 10px -6px 10px 3px rgba(0, 0, 0, 0.23),
    inset -1px 1px 10px 0.5px rgb(250, 249, 247);
}

/* NOTE Cuando se quiere manipular el Z-axis de un elemento o el orden en que se apila con otros elementos hay que entender dos conceptos: Stacking order, el cual se resume a que los elementos mas antiguos quedan sepultados por los más nuevos, este orden lo tienen todos los stacking contexts. Every stacking context has a single HTML element as its root element, eso quiere decir que todos los elementos que incluyas desde el inicio forman parte del 1er stacking context constituido por la etiqueta/elemento HTML. Los elementos adquieren stacking context con algunas propiedades como opacity y transform o con la combinación de “position value other than static and a z-index value other than auto”. Un elemento con stacking context tiene su propio stacking order y sus hijos no pueden interactuar o sobreponerse sobre elementos fuera del stacking context de su padre, sin importar lo alto que tenga el valor de Z-Index. */
/*NOTE Stacking Order Within the Same Stacking Context... Here are the basic rules to determine stacking order within a single stacking context from back to front 1)The stacking context’s root element. 2) Positioned elements (and their children) with negative z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML). 3) Non-positioned elements (ordered by appearance in the HTML). 4) Positioned elements (and their children) with a z-index value of auto (ordered by appearance in the HTML). 5) Positioned elements (and their children) with positive z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML). */

.upper-main {
  /* Esta es la luna menguante que es papa de los planetas pequenos ".content y .side-bar", es en realidad un planeta grande azul/fucsia que da la impresion de ser una luna menguante gracias al otro div redondo y rosado que es hermano de este */
  position: relative;
  z-index: -4;
  background: linear-gradient(
    328deg,
    rgba(69, 189, 252, 1) 1%,
    rgba(107, 29, 253, 1) 40%,
    rgba(253, 29, 173, 1) 90%
  );
  box-shadow: 0 19px 20px 3px rgba(0, 0, 0, 0.23),
    inset 10px -6px 10px 3px rgba(0, 0, 0, 0.23),
    inset -1px 1px 10px 0.5px rgb(250, 249, 247);
  height: 90vh;
  width: 100vw;
  border-radius: 50%;
  margin: 5vh auto 5vh;
  /* Se agrego el margin on top and bottom */
}

/* HACK Sin float este toma su lugar normal en el flow, despeja hacia abajo a su hermano bloque .upper-main */
.divfortesting-zindex {
  background: #c58daa;
  height: 65vh;
  width: 80vw;
  float: left;
  border-radius: 50%;
  margin: 1em 0 0 1em;
  box-shadow: 20px 10px 10px rgba(0, 0, 0, 0.23);
}
/*HACK Width on ".main-container" kind of fixes side scrolling on a desktop viewport since the image was a bit wider than the actual size of my laptop screen was less than 1350px which is the size of the image */
/* HACK Pense en como logre que el .main-container fuera translucido sin usar opacity, evitando asi el stacking context que opacity añade, esto con el objetivo de que sus hijos detras con Z-Index pudieran ser visto. Es posible gracias a background: linear-gradient. */
.main-container {
  /* Papa de todos en la seccion de planetas */
  /* position: relative; */
  /* z-index: 4; */
  background: linear-gradient(
    180deg,
    rgba(187, 119, 154, 0.85),
    rgba(187, 119, 154, 0.65),
    rgba(187, 119, 154, 0.03)
  );
  overflow: hidden;
  height: 110vh;
  width: 100vw;
}
/* NOTE I just tried to uncomment position & Z-Index properties for the div above, .main-container or "the father of them all" to try on it a even lower Z-Index (lower than .upper-main), in order to put the translucid pinky background behind .upper-main and its two children, the problem lies in giving back a stacking context to .main-container which confines all its children and, therefore not allowing the trick of negative values on Z-Index which lets you put children behind parents. */
/*HACK con overflow hidden el texto debajo de esta seccion no se cola al inicio, recuerde q float saca los elementos del flow normal, los elementos siguientes tomarian su lugar, para que overflow hidden sea efectivo se tiene que usar en el papa de los hijos que estan flotando  */
/* NOTE Esto explica el primer set de planetas: el porque .upper-main junto a sus hijos quedan detras del papa de toda la seccion .main-container, el cual tiene una transparencia, lo cual deja ver a sus hijos detras: 1- Empezamos con el papa .main-container, que al no estar posicionado se ubica por encima de elementos con Z-Index negativo. 2- Su hijo directo, .upper-main se encuentra posicionado y tambien adquiere stacking context al tener Z-Index diferente a auto, lo cual arrastra a sus hijos con el. 3- Es indiferente si los hijos de .upper-main (.sidebar y .content) tienen stacking context o no, ya que su padre los confina dentro de el al tener stracking context. Como nota si se quisiera que otro elemento se sobreponga a .main-container tendria que ser un elemento hermano de .upper-main, en otras palabras un elemento fuera del stacking context de .upper-main, un elemento que reune esas especificaciones seria ".divfortesting-zindex", .divfortesting-zindex no requiere Z-Index para estar on top of everything else ya que el stacking order default del root HTML, lo posiciona encima de su padre directo .main-container     */
/* Second section, just bellow landpage End First Part*/
/* <<<<<<<<<<<<<<<<<--------------->>>>>>>>>>>>>>>>>>> */
/* Second section, just bellow landpage Start Second Part*/
/* HACK aqui estamos estamos aplicando estilos en cascada a upper-main gracias a una segunda clase para la misma etiqueta, de esta forma me ahorro escribir estilos innecesarios solo sobrescribo los estilos que quiero cambiar como el background color, el resto lo mantengo igual con los estilos de la primer clase en esta etiqueta */
.upper-main-II {
  /* background: rgb(70, 39, 73); */
  background: linear-gradient(
    0deg,
    rgba(70, 39, 73, 1) 24%,
    rgba(131, 50, 172, 1) 51%,
    rgba(224, 134, 211, 1) 77%
  );
  position: static;
}
/*HACK Had to give .upper-main-II above a static position cause it was inheriting position: relative from the 1st .upper-main styles, which was giving it stacking context, as a result it didnt let me put one of .upper-main's children behind it.
/* NOTE Cambiado el angulo de gradient y grandient transition entre 1ra y 2da parte */
.main-container-II {
  /* NOTE cuando el angulo del gradient es 0 el primer color listado en CSS se renderiza abajo de todos en la página web. */
  /* NOTE notese que esta clase fue hecha solo para cambiar la direccion del gradient del .main-container de la 2da parte y que transicione suavemente con el tono transparente con el que termina el .main-container de la 1ra parte.  */
  background: linear-gradient(
    0deg,
    rgba(187, 119, 154, 0.95),
    rgba(187, 119, 154, 0.65),
    rgba(187, 119, 154, 0.03)
  );
  /* position: relative; */
  /* z-index: -1; */
}
/*HACK In line #232 he have another H A C K that explains why the div below, .side-bar-II is behind its direct parent, .upper-main-II. But why does it go beyond and it is also behind .main-container-II? The parent of its parent. The most evident fact as to why that happens is that .main-container-II does not have stacking context, nor directly or indirectly cascading from .main-container from the section #1 of planets. So, when stacking context is added (in this example I decided to use Position+Z-Index to trigger it), the .side-bar-II can not longer be behind .main-container-II, because the parent of the parent has stacking context now. Excepto cuando el valor Z-Index es auto, debido a que asi no aplica stacking context a .main-container-II y por lo tanto .side-bar-II puede escapar y colocarse detras.*/
/*SEARCH Este raro comportamiento relacionado al stacking order/context entre .main-container-II y .side-bar-II puede ser a causa de la cercania de estos dos DIVS con la etiqueta HTML. Por un lado tengo al div de abajo .side-bar-II que tiene un padre directo (.upper-main-II que no tiene stacking context) y un valor de Z-Index de -2, por otro lado tengo al papá del papá (.main-container-II, el cual es papá de .upper-main-II y abuelo de .side-bar-II), que también tiene un Z-Index negativo de -1. Lo raro es que a pesar de tener un valor Z-Index mas alto sigue detrás de .side-bar-II que tiene un valor Z-Index menor de -2. En este escenario, it seems that as long as there is stacking context on .main-container-II the .side-bar-II won't get behind .main-container-II even if it has a lower Z-Index. SO, for the momment I will comment the stacking context triggering properties on .main-container-II (just because I want to have .side-bar-II behind the grandpa). */
.side-bar-II {
  right: 15vw;
  position: relative;
  z-index: -2;
  top: 12vh;
  border: solid 6px red;
}
.content-II {
  position: relative;
  top: 20vh;
  right: 10vh;
}
.divfortesting-zindex-II {
  /* position: relative;
  z-index: 3; */
  background: rgba(187, 119, 154, 0.1);
  height: 65vh;
  width: 70vw;
  float: left;
  border-radius: 50%;
  margin: 2em 0 0 1.8em;
  box-shadow: 15px 10px 10px rgba(0, 0, 0, 0.23);
}
/* Second section, just bellow landpage End Second Part*/
/* <<<<<<<<<<<<<<<<<--------------->>>>>>>>>>>>>>>>>>> */
/* Second section, just bellow landpage Start Third Part*/
.main-container-III {
  background: linear-gradient(
    180deg,
    rgba(187, 119, 154, 0.95),
    rgba(187, 119, 154, 0.65),
    rgba(187, 119, 154, 0.03),
    rgba(255, 255, 255, 1)
  );
  box-shadow: inset 0 -2rem 1rem -1rem #ffcccc,
    inset 0 -14rem 10rem -7rem #ffcccc;
  /* NOTE put this border for a smooth transition between third set of planets and linear strip gradient practice */
}
.divfortesting-zindex-III {
  background-color: aqua;
}
/*SEARCH Podemos ver que .divfortesting-zindex-III está en medio de su hermano .upper-main-III y el planeta rojo (.content-III hijo de .upper-main-III), pero cómo?? Si divfortesting-zindex-III no tiene en ninguna de las 2 clases alguna propiedad que altere su stacking order o que le de stacking context, así que el primer sospechoso fué .content-III (planeta rojo) que  somehow tenia 2 floats, uno en .content-III, el cual comenté, pero el que no quize comentar fue en .content, ya que al comentar ese float provocaba conflictos en el layout de las otras secciones de planetas pasadas. En fin, pude deducir que los elementos flotantes siguen orden de aparición aunque ya no pertenezcan al flow normal del layout, ya que tanto .divfortesting-zindex-III como .content-III se ven afectados por float properties de sus contrapartes mas antiguas en el código (.divfortesting-zindex y .content), asi que flotan pero respetan el orden en el que aparecen en el código de HTML, primero estando .divfortesting-zindex-III y luego .content-III, el papa de .content-III that just happens to be behind there, creates the effect that .divfortesting-zindex-III got between father and son somehow when it actually just occupies the blank space left by its brother .divfortesting-zindex-III that now just hovers over it */
.upper-main-III {
  position: static;
  /* HACK This hack allows to revert what the original styles do (this refers to the 1st .upper-main), with this the original stacking context that .upper-main had was disabled, ya que el value static es valor por defecto que no deja a Z-Index funcionar */
}
.side-bar-III {
  position: relative;
  z-index: -1;
  margin-left: 14vw;
}
.content-III {
  width: 35vw;
  height: 20vh;
  /* float: right; */
  border-radius: 50%;
  background: linear-gradient(
    205deg,
    rgba(131, 58, 180, 1) 0%,
    rgba(253, 29, 29, 1) 50%,
    rgba(252, 176, 69, 1) 100%
  );
  margin: -2rem 1rem 0 0;
  box-shadow: -10px 6px 10px 3px rgba(0, 0, 0, 0.23),
    inset 10px -6px 10px 3px rgba(0, 0, 0, 0.23),
    inset -1px 1px 10px 0.5px rgb(250, 249, 247);
}

/* Second section, just bellow landpage End Third Part*/

/* START map testing */
.secondmaptag {
  display: block;
}
/* NOTE @media below hecho para desaparecer mapped images en dispositivos con dimensiones menores a 350px */
@media only screen and (max-width: 350px) {
  .maptesting {
    display: none;
  }
}
/* End map testing */

/* Start gradient-stripe practice  */
.gradient-background {
  /* background: linear-gradient(90deg, red, yellow, rgb(204, 204, 255)); */
  height: 100vh;
  width: 100vw;
  /* NOTE fixed side scrolling adding full width to the background  */
  padding: 3rem;
  background: linear-gradient(360deg, #ccffff, #ffcccc);
}
.red-stripes {
  /* NOTE Despite having lots of exercices bellow on the animations/transitions section practice, these stripes were the last practice about animations/transitions that I made. Before trying Transform + Transition properties on the color stripe divs I had altered the stacking context of the red stripes when used opacity on them, which placed them on top of the yellow stripes, even if the yellow stripes are located last on the HTML stacking order, which would put the yellow ones on top of the red ones in normal circunstances. There was 2 ideas on using opacity: 1st Allow viewers to notice how red and yellow stripes were stacked on each other, 2nd Put red stripes on top the yellow stripes. But then I used transition on the yellow stripes which initially had a regular HTML stacking order (REASON WHY THEY WERE BENEATH THE RED STRIPES).. what happened then? The yellow stripes got back on top of the red stripes. Why?: As soon I used transition on the yellow stripes they adquired stacking context, just like the red stripes did when I used property opacity on them, so now that both red and yellow stripes have stacking context they both drop back on HTML stacking order rules! Which puts the yellow stripes back on top again because they are located later than the red ones (REMEMBER THE SOURCE ORDER). Solution?: I had to give the red stripes a higher z-index value than the yellow ones, however since neither stripe color was positioned I had to position both first.  */
  position: relative;
  z-index: 2;
  height: 45vh;
  width: 65vw;
  margin: 0 0 0 2.94rem;
  opacity: 0.8;
  /* NOTE recordemos que opacity "con valor menor a 1" nos da stacking context por lo cual las barras rojas se colocan encima de las barras amarillas a pesar de estar situadas antes de las amarillas en el stacking order de HTML root, N O T E S E que las barras amarillas se estan rigiendo por el stacking context de HTML root.  */
  background: repeating-linear-gradient(
    45deg,
    red 0px,
    red 40px,
    black 40px,
    black 80px
  );
  border-radius: 5%;
  transform: scale(1);
  transition-property: transform;
  transition-duration: 1000ms;
}

.red-stripes:hover {
  transform: scale(1.4);
}
.yellow-stripes {
  position: relative;
  z-index: 1;
  height: 45vh;
  width: 65vw;
  margin: -4.05rem 2.5rem 0 0;
  /* HACK El truquito de poner las yellow bars debajo lo hace el margin negativo, gracias a que las barras rojas estan en otro stacking context gracias a opacity. */
  border-radius: 5%;
  background: repeating-linear-gradient(
    135deg,
    yellow 0px,
    yellow 40px,
    black 40px,
    black 80px
  );
  transform: scale(1);
  transition-property: transform;
  transition-duration: 1000ms;
}
.yellow-stripes:hover {
  transform: scale(1.4);
}
/* End gradient-stripe practice  */
/* <<<<<<<<<<------>>>>>>>>>>> */
/* Making a heart that has a common radial gradient (Transition & Animations Practice) - Start*/
.heart-background {
  height: 60vh;
  width: 100vw;
  /* NOTE had to add width to stop side scrolling */
  background: linear-gradient(180deg, #ccffff, #ffcccc);
  /* padding-top: 5vh; */
}
.square {
  /* HACK Se descubrio que para hacer un gradient con transicion mas suave se pueden crear muchos puntos de transicion con la pagina "https://cssgradient.io/" */
  background: linear-gradient(
    225deg,
    rgba(255, 204, 204, 1) 79%,
    rgba(254, 197, 199, 1) 80%,
    rgba(253, 190, 194, 1) 81%,
    rgba(252, 183, 189, 1) 82%,
    rgba(251, 176, 184, 1) 83%,
    rgba(250, 169, 179, 1) 84%,
    rgba(249, 162, 174, 1) 85%,
    rgba(248, 155, 169, 1) 86%,
    rgba(247, 148, 164, 1) 87%,
    rgba(246, 141, 159, 1) 88%,
    rgba(246, 134, 154, 1) 89%,
    rgba(245, 127, 149, 1) 90%,
    rgba(245, 120, 144, 1) 91%,
    rgba(244, 113, 139, 1) 92%,
    rgba(244, 106, 134, 1) 93%,
    rgba(244, 106, 134, 1) 93%,
    rgba(243, 99, 129, 1) 94%,
    rgba(243, 92, 125, 1) 95%,
    rgba(242, 85, 120, 1) 96%,
    rgba(242, 78, 116, 1) 97%,
    rgba(240, 55, 102, 1) 100%
  );
  width: 31.2vw;
  height: 17.5vh;
  margin: auto;
  /* HACK The only property that pushed the heart down without pushing down its father as well was top: 15vh, the one bellow, I just didnt want to relay on its parent padding property to push it down, but margin-top would't let me to push it down because it was pushing its parent ".heart-background" as well and created a blank gap between the gradient backgrounds, as to why that happened, the property "tranform: rotate(-45deg)" and "margin: auto" property had to do with that, first, "margin: auto" helps to center the square by creating equally sized margins to the left and right but then tranform: rotate(-45deg) changes the orientation of the square's margins on both sides while keeping the squAre centered, however that pushes up the right side margin's top corner agaisnt the edge of its parent ".heart-background" (TO SEE THIS, USE CHROME DEVTOOLS AND HOVER OVER THIS ELEMENT SO YOU CAN SEE WHERE THE MARGIN POINTS AND HOW THAT ALONG WITH TRANFORM CREATES THE BLANK GAP ON TOP), beyond this point, the wider the right margin is (in this example) the more gap there will be between the 2 grandient backgrounds, so now.. the reason why margin-top was making this blank gap is because the right side margin's top corner will get further as margin right or top increase, therefore the gap gets larger. The other workaround I think is to make the whole heart smaller. */
  top: 15vh;
  transform: rotate(-45deg);
  position: relative;
  /* HACK descubri esta pagina que permite crear sombras facilmente "https://www.cssmatic.com/box-shadow", pero hay muchas opciones de paginas que crean efectos muy ingeniosos */
  -webkit-box-shadow: -25px 25px 9px -19px rgba(0, 0, 0, 0.45);
  -moz-box-shadow: -25px 25px 9px -19px rgba(0, 0, 0, 0.45);
  box-shadow: -25px 25px 9px -19px rgba(0, 0, 0, 0.45);
  animation-name: beat;
  animation-duration: 1500ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0, -0.29, 0.4, 0.5);
}
/* COMMIT (Will be a H A C K) When there is a keyframe rule set in the middle of the animation duration (at 50%), it results in two identical animation progressions at the upward and downward movement of an element. */
/* COMMIT (WILL BE A H A C K) In order to make a 3 dot loading indicator in which the dots move at different pace we need the code that is commented just bellow*/
/* <style>
  .balls {
    border-radius: 50%;
    position: fixed;
    width: 50px;
    height: 50px;
    top: 60%;
    animation-name: jump;
    animation-duration: 2s;
    animation-iteration-count: infinite;
  }
  #red {
    background: red;
    left: 25%;
    animation-timing-function: linear;
  }
  #blue {
    background: blue;
    left: 50%;
    animation-timing-function: ease-out;
  }
  #green {
    background: green;
    left: 75%;
    animation-timing-function: cubic-bezier(1, 1, 2, 2);
  }

  @keyframes jump {
    50% {
      top: 10%;
    }
  }
</style>
<div class="balls" id="red"></div>
<div class="balls" id="blue"></div>
<div class="balls" id="green"></div> */

/* <<<<<<<<<<<<<<<oooooo>>>>>>>>>>>>>>>> */

/* Making the heart beat - Start */
@keyframes beat {
  50% {
    /* NOTE con "@keyframes beat" me di cuenta que no se ocupa transform: matrix, siempre y cuando la sintaxis de los values sea correcta. */
    transform: scale(1.4) rotate(-45deg);
  }
}
/* Making the heart beat - End */
.square::before {
  content: "";
  background: #ffcccc;
  width: 30vw;
  height: 17.5vh;
  /* margin-top: -15vh; */
  border-radius: 50%;
  position: absolute;
  transform: rotate(45deg);
  top: -8.5vh;
  left: 0.4vw;
  box-shadow: inset 13px 15px 15px -13px #f03766;
}
/* NOTE Without property content: "";, the pseudo elements ::before or ::after won't show. */
/* NOTE If property content: "" is empty.. every part, including the parent as well as the children "::before & ::after" has to be positioned in order to render (Of course, it needs some other properties in order to show like height and background color), Then, once every part is rendered we can move them around the parent with top, bottom, left and right. If there is something in between the quotation marks like a bullet point E.g, it'll show elements before or after the selected element, like it was tested on the code bellow ".square::after" that was deleted. */
/* HACK It would've been dificult to place the purple shades over the upper rounded parts of the heart, where I wanted and the way I wanted without transform: rotate().  */
.square::after {
  content: "";
  background: #ffcccc;
  width: 30vw;
  height: 17.5vh;
  border-radius: 50%;
  position: absolute;
  transform: rotate(137deg);
  left: 15.7vw;
  top: 0.08vh;
  box-shadow: inset 11px 12px 15px -12px #f03766;
}

/* Making a heart that has a common radial gradient - End*/
/* NOTE There was an element styled here, right before ".square::after" that was deleted at some point. The point was to see what a content: "" property does with something inside as content, E.g, a dot. */

/* Here I practice transitions & animations - Start  */
.trans-animation {
  width: 100vw;
  height: 150vh;
  background: linear-gradient(0deg, #ccffff, #ffcccc);
  perspective: 140px;
  /* NOTE Perspective allows all direct children of any container to be 3D styled, in this case both children of .trans-animation (.simple-box & .shadow-box) will be 3D styled thanks to the perspective given to their parent .trans-animation. Then, there are 2 ways of using perspective: 1st As a property with a value like the one above, following the details in this comment. 2nd: As a value or function should I say of the property transform. (See: https://3dtransforms.desandro.com/perspective) */
  animation-name: perspective;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0.5, 0.05, 1, 0.5);
}
/* HACK Transform-style: preserve-3d was not needed in this Box & Shadow section = There were no children of children needed to make this animation/transition practice or in other words .trans-animation has no grand-children, REMEMBER: Perspective only enables direct children of a given element to be 3D styled. So to fix that there is transform-style: preserve-3d, however in this case it was not needed. */
@keyframes perspective {
  0% {
    perspective: 150px;
  }
  80% {
    perspective: 200px;
  }
  100% {
    perspective: 150px;
  }
}
.simple-box {
  width: 34vw;
  height: 20vh;
  background-color: #8332ac;
  margin: 0vh auto 0vh;
  border-radius: 50%;
  animation-name: ok;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
  animation-timing-function: cubic-bezier(0.5, 0.05, 1, 0.5);
  /* NOTE This "@keyframes ok" translates the div vertically (through y-axis) and scales it in different ways. So first, there is a "transform: matrix" property at 0% which changes nothing so it stays the same till it gets to the 80% of the animation within its duration of 1000ms or 1sec, towards the end of the animation the ball turns back to the same position and form.  */
}
/* HACK DO NOT USE "ALL" with transition, cause it hurts the performance */

@keyframes ok {
  0% {
    background-color: #8332ac;
    transform: matrix(1, 0, 0, 1, 0, 0);
  }
  /* NOTE The comma between the x & y axis values is necessary for proper function of matrix transform properties. */
  80% {
    background-color: aquamarine;
    /* transform: translate(0vw, 34vh); */
    transform: matrix(1.3, 0, 0, 0.65, 0, 251);
    /* HACK Found a page that helps with creating 2D transform matrixes. http://angrytools.com/css-generator/transform/ */
  }
  100% {
    transform: matrix(1, 0, 0, 1, 0, 0);
  }
}
.shadow-box {
  opacity: 0.3;
  background-color: rgba(0, 0, 0, 0.55);
  margin: 0vh auto 0vh;
  box-shadow: 2px 2px 11px 34px rgba(0, 0, 0, 0.55);
  width: 24vw;
  height: 13vh;
  border-radius: 50%;
  transform: translateY(70vh) rotateY(125deg);
  animation-name: not-ok;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0.5, 0.05, 1, 0.5);
  /* HACK (Look for the 5 commented properties in .shadow-box) The next 5 properties bellow this "Hack|Comment" make a perfect isosceles trapezoid, the problem is that no shadow effects can be applied because box-shadow still outlines the squared shape of divs, instead of the trapezoid made thanks to the border properties, when making shapes with borders only there is no really a body in which a shadow can cast around. */
  /* border-bottom: 100px solid rgba(0,0,0,0.55); */
  /* border-left: 15px solid transparent;
  border-right: 15px solid transparent;
  height: 0;
  width: 44vw; */
  /* HACK I continued searching other ways to input the isosceles trapezoid shape bellow the bouncing div, but then I saw this other hack that implies HTML unicode shapes, however I couldn't find an isosceles trapezoid on google, so I had to rely on the perspective property, which actually works perfectly, IMPORTANT: The perspective property goes on the father of the element we need to change (In this case .trans-animation) and then it trigers when applying transform to the child. */
}
@keyframes not-ok {
  0% {
    opacity: 0.3;
    /* HACK Before I tried a negative value on the rotate's VALUE I was getting this weird issue with the shadow agaisnt or closer to the screen was going upwards at 80% of the animation or so, when it was supposed to go up while keeping the same degree on the X axis, since I was using the same VALUE for both, the animation and .shadow-box (TEST IT BY USING A POSITIVE VALUE ON THE ROTATE'S VALUE INSTEAD OF NEGATIVE */
    transform: translateY(70vh) rotateX(-125deg) scale(1);
  }
  80% {
    opacity: 0.6;
    /* HACK Before I tried a negative value on the rotate's VALUE I was getting this weird issue with the shadow agaisnt or closer to the screen was going upwards at 80% of the animation or so, when it was supposed to go up while keeping the same degree on the X axis since I was using the same VALUE for both, the animation and .shadow-box (TEST IT BY USING A POSITIVE VALUE ON THE ROTATE'S VALUE INSTEAD OF NEGATIVE. */
    transform: translateY(34.5vh) rotateX(-125deg) scale(1.1, 1.8);
    box-shadow: 2px 2px 3px 22px rgba(1, 0, 0, 0.55);
    /* HACK So.. this is the animation of the shadow but, initially it had a squared shape too and was given a perspective property to give it a 3D effect, so in order to make the shadow mimick both shape and actions of the bouncing ball I had to give the shadow a border-radius: 50% property so the shadow mimicks the ball's rounded shape when it is on the "air" as well as animation/transformation so the shadow mimicks the shape of the ball when it hits the "ground" and gets squished, however an animation with 2D transformation wouldn't help, I had to use an animation with 3D tranform and here's where I thought I had to use the matrix value to apply more than 1 transform value.. I was applying multiple transform values incorrectly, I was doing it this way: {transform: translate(x, x); transform: scale(x, x); That is wrong},but then I found out that when you need multiple values for transform you only need to type the transform property once and then add as many values as you need, like this: {transform: translate(x, x) scale(x, x)}. So i'm going to comment transform matrix bellow this hack/comment and continue with the easy way above. */
    /* transform: matrix3d(1.2,0,0,0,0,0.9,0,-0.001,0,0,1,0,0,0,0,1); */
    /* transform: translate(10vw -10vh); */
    /* HACK The box-shadow property above is what I used to make the shadows' edges sharper as well as decreasing the size. */
  }
  100% {
    opacity: 0.3;
    /* HACK Before I tried a negative value on the rotate's VALUE I was getting this weird issue with the shadow agaisnt or closer to the screen was going upwards at 80% of the animation or so, when it was supposed to go up while keeping the same degree on the X axis since I was using the same VALUE for both, the animation and .shadow-box (TEST IT BY USING A POSITIVE VALUE ON THE ROTATE'S VALUE INSTEAD OF NEGATIVE */
    transform: translateY(70vh) rotateX(-125deg) scale(1);
  }
}
/* Cloud section - Start */
/* NOTE This may be within the transition practice section but it works like a splitter from the bouncing ball and the stars. */
/* HACK We can the get the cloud image between the dark and pink linear backgrounds in two ways: 1st: We can put the img tag with class .cloud above the div with class .nightsky so then we can kick the .cloud img tag off the normal HTML flow with the property float, upon that the .nightsky div will follow the normal flow and stick to the pink background above, creating the ilusion the .cloud figure tag is above both linear backgrounds as it is no longer part of the normal flow thanks to the property float. No position property needed in this way. 2nd: We can get the same results without "float" by putting the img tag .cloud inside .nightsky div which has a linear background that renders fine around the img .cloud (child) even though the figure tag .parent (parent) along its child are on top. So why does the linear background of the div .nightsky renders like that despite having two elements on top?  It is due to 3 reasons: a) The format given to the img .cloud (SVG). b) the fact that the parent element with class .parent is transparent due to lack of CSS height or background properties. c) Position: relative given to the img .cloud, which then got placed on the right place thanks to top & left. */
.cloud {
  /* position: absolute; */
  position: relative;
  /* float: left; */
  top: -41.9vh;
  left: -3.597vw;
  margin: 0;
  width: 100vw;
  transform: scale(1.088);
}
/* NOTE It was necessary to apply position and drag up the figcaption so it followed the cloud image. */
figcaption {
  position: relative;
  top: -11vh;
  text-align: center;
  opacity: 0.5;
  color: white;
}
.nightsky {
  /* position: relative; */
  width: 100vw;
  height: 100vh;
  background: linear-gradient(black, #000099, #66c2ff, #ffcccc, #ffeee6);
}
.stars {
  position: relative;
  width: 7vw;
  height: 4vh;
  border-radius: 50%;
  background-color: aliceblue;
  clip-path: polygon(
    51% 18%,
    58% 40%,
    79% 46%,
    59% 56%,
    51% 78%,
    42% 56%,
    22% 47%,
    43% 40%
  );
}
.star-one {
  top: 28%;
  left: 85%;
  animation-name: blink-one;
  animation-duration: 2000ms;
  animation-iteration-count: infinite;
  transform: scale(0.7);
  opacity: 0.5;
}
@keyframes blink-one {
  50% {
    transform: scale(1.7);
    opacity: 1;
  }
}
.star-two {
  top: 40%;
  left: 40%;
  animation-name: blink-two;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  opacity: 0.7;
}
@keyframes blink-two {
  50% {
    transform: scale(1.2);
    opacity: 1;
  }
}
.star-three {
  top: 25%;
  left: 20%;
  animation-name: blink-three;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0, -0.29, 0.4, 0.5);
  opacity: 0.9;
}
@keyframes blink-three {
  50% {
    transform: scale(1.3);
    opacity: 1;
  }
}
.star-black {
  top: 55vh;
  left: 75vw;
  background-color: black;
  animation-name: black-star;
  animation-duration: 3000ms;
  animation-iteration-count: infinite;
  transform: scale(0.85);
}
@keyframes black-star {
  50% {
    transform: scale(1.4);
  }
}
/* Cloud section - End */
/* Here I practice transitions & animations - End  */

/* Outline y Border */
.one {
  width: 80%;
  margin: 1rem auto;
  outline: 0.1rem solid red;
  outline-offset: -0.2rem;
}
.two {
  width: 80%;
  margin: 1rem auto;
  border: 0.1rem solid red;
}

[type="radio"] {
  /*NOTE Para dar estilo a los inputs del form */
  margin: 20px 0px 20px 0px;
}
