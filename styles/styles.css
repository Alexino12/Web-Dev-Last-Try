* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
:root {
  /* random shit */
  --outline-edges-theme: 0.04rem solid #8332ac;
  /* --boxshadow: 0.1rem 0.1rem 1rem black; */
  /* bg colors */
  --body-bg-color: rgba(187, 119, 154, 0.5);
  --overlay-color: rgba(45, 35, 46, 0.85);
  /* fonts and paragraph related */
  --font-family-not-header: "Gayathri", sans-serif;
  --font-color: white;
  --overall-line-height: 1.4;
  --letterspacing: 0.15rem;
  /*--------- unknown custom properties ---------*/
  --menu-speed: 0.75s;
  /* layout handling */
  --section-fullheight: 100vh;
}
body {
  /* NOTE Quité la estupidez de las variantes */
  font-family: "Gayathri", sans-serif;
  line-height: 1.4;
  width: 100vw;
}
.logo {
  width: 10vw;
  /*NOTE The positioning is done relative to the first relatively (or absolutely) positioned parent element. In the case when there is no positioned parent element, it will be positioned related directly to the HTML element (the page itself).  */
  position: absolute;
  /*NOTE Positioning properties like bellow create a gap towards the left between the parent (body) and itself (logo) */
  left: 87vw;
  top: 2vh;
  z-index: 2;
}
/* This is the section where the main image is  */
.shakepic {
  /* NOTE quite la estupidez de las variantes */
  position: absolute;
  height: 100vh;
  z-index: 0;
  width: 100vw;
  /* HACK width property fixes cross-scrolling */
}
.container {
  width: 100vw;
  margin: auto;
  overflow: hidden;
  /*  */
  position: relative;
  z-index: 1;
  /* NOTE quite la estupidez de las variantes */
  background: rgba(187, 119, 154, 0.5);
  box-shadow: inset 0 -2rem 1rem -1rem #c58daa,
    inset 0 -14rem 10rem -10rem #c58daa;
  /*  HACK This Box Shadow is what makes a degraded between first and second sections */
}

.showcase {
  /* NOTE quite la estupidez de las variantes */
  color: white;
  height: 100vh;
  /*  REVIEW removing showcase's position may cause errors position: relative; */
}
.showcase .showcase-inner {
  align-items: center;
  text-align: center;
  height: 100vh;
  letter-spacing: 0.15rem;
  padding: 19vh 14vw 0 14vw;
}
.showcase h1 {
  font-size: 2.2rem;
}
.showcase p {
  letter-spacing: 0.15rem;
  padding-top: 4vh;
  text-align: justify;
}
/* Styling for the BUTTON */
.btn {
  display: inline-block;
  font-weight: bold;
  border: none;
  /* NOTE quite estupidez de variantes */
  background: rgba(187, 119, 154, 0.5);
  color: white;
  padding: 5vh 9vw;
  margin-top: 14vh;
  text-decoration: none;
  border-radius: 8%;
  /* NOTE quite estupidez de variantes */
  border: 0.04rem solid #8332ac;
  /*NOTE el 1er valor es el eje horizontal, el 2do el vertical, el 3ro el blur, el 4to alarga las sombra hacia todas direcciones */
  /*HACK en esta propiedad los dos primeros valores de sombras proyectan sombra hacia abajo creando un efecto de blur y oscuridad mas marcados y que no se logra con un solo value de sombra */
  /*HACK tambien se puede usar 3 valores inset lo que logra 3 colores distintos dentro, hay que jugar bastante con el 4 value de las sombras para lograr esto */
  box-shadow: 0 10px 10px rgba(0, 0, 0, 0.19), 0 19px 19px rgba(0, 0, 0, 0.23),
    inset 0 -15px 28px #a469c2;
}
/* Start of styles for landpage button */
/* NOTE agregue pseudo clases para el boton "READ MORE" del landpage, utilize por primera vez transform property */
.btn:link {
  color: white;
}
.btn:visited {
  color: rgb(247, 48, 81);
}
.btn:hover {
  /* NOTE Recordemos que en mobiles el hover no renderiza, en mobiles el hover se acciona al hacer "tap" */
  background: rgba(157, 119, 154, 0.5);
}
.btn:active {
  /* NOTE La pseudo clase :active fue a la que mas propiedades se le dio, incluyendo Transform */
  border: 0.04rem solid white;
  background: #f1a5b7;
  opacity: 0.65;
  box-shadow: 0 10px 10px rgba(0, 0, 0, 0.59), 0 19px 19px rgba(0, 0, 0, 0.23),
    inset 0 -15px 28px #be4a66;
  transform: scale(1.06);
}
/* End of styles for landpage button */

/* Second section, just bellow landpage Start First Part*/
/* NOTE En esta seccion se explica mediante comments como esta compuesta la seccion de los planetas*/
.side-bar {
  /* position: relative; */
  /* z-index: -1; */
  width: 18vw;
  height: 13vh;
  margin-right: 5vw;
  border-radius: 50%;
  float: right;
  background: linear-gradient(
    130deg,
    rgba(131, 58, 180, 1) 0%,
    rgba(253, 228, 29, 1) 50%,
    rgba(252, 176, 69, 1) 100%
  );
  box-shadow: inset 10px -6px 10px 3px rgba(0, 0, 0, 0.23),
    inset -1px 1px 10px 0.5px rgb(250, 249, 247);
}

.content {
  width: 35vw;
  height: 20vh;
  float: right;
  /* Sin float este elemento vuelve al flow normal como su hermano .side-bar, el cual es un bloque que es parte ya del flow normal como hijo de .upper-main, el div bloque de .side.bar que ocupa todo el ancho del viewport no permite otros elementos a la par, por eso este div se coloca justo por debajo al remover float */
  border-radius: 50%;
  background: linear-gradient(
    205deg,
    rgba(131, 58, 180, 1) 0%,
    rgba(253, 29, 29, 1) 50%,
    rgba(252, 176, 69, 1) 100%
  );
  margin: -2rem 1rem 0 0;
  box-shadow: -10px 6px 10px 3px rgba(0, 0, 0, 0.23),
    inset 10px -6px 10px 3px rgba(0, 0, 0, 0.23),
    inset -1px 1px 10px 0.5px rgb(250, 249, 247);
}

/* NOTE Cuando se quiere manipular el Z-axis de un elemento o el orden en que se apila con otros elementos hay que entender dos conceptos: Stacking order, el cual se resume a que los elementos mas antiguos quedan sepultados por los más nuevos, este orden lo tienen todos los stacking contexts. Every stacking context has a single HTML element as its root element, eso quiere decir que todos los elementos que incluyas desde el inicio forman parte del 1er stacking context constituido por la etiqueta/elemento HTML. Los elementos adquieren stacking context con algunas propiedades como opacity y transform o con la combinación de “position value other than static and a z-index value other than auto”. Un elemento con stacking context tiene su propio stacking order y sus hijos no pueden interactuar o sobreponerse sobre elementos fuera del stacking context de su padre, sin importar lo alto que tenga el valor de Z-Index. */
/*NOTE Stacking Order Within the Same Stacking Context... Here are the basic rules to determine stacking order within a single stacking context from back to front 1)The stacking context’s root element. 2) Positioned elements (and their children) with negative z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML). 3) Non-positioned elements (ordered by appearance in the HTML). 4) Positioned elements (and their children) with a z-index value of auto (ordered by appearance in the HTML). 5) Positioned elements (and their children) with positive z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML). */

.upper-main {
  /* Esta es la luna menguante que es papa de los planetas pequenos ".content y .side-bar", es en realidad un planeta grande azul/fucsia que da la impresion de ser una luna menguante gracias al otro div redondo y rosado que es hermano de este */
  position: relative;
  z-index: -4;
  background: linear-gradient(
    328deg,
    rgba(69, 189, 252, 1) 1%,
    rgba(107, 29, 253, 1) 40%,
    rgba(253, 29, 173, 1) 90%
  );
  box-shadow: 0 19px 20px 3px rgba(0, 0, 0, 0.23),
    inset 10px -6px 10px 3px rgba(0, 0, 0, 0.23),
    inset -1px 1px 10px 0.5px rgb(250, 249, 247);
  height: 90vh;
  width: 100vw;
  border-radius: 50%;
  margin: 5vh auto 5vh;
  /* Se agrego el margin on top and bottom */
}

/* HACK Sin float este toma su lugar normal en el flow, despeja hacia abajo a su hermano bloque .upper-main */
.divfortesting-zindex {
  background: #c58daa;
  height: 65vh;
  width: 80vw;
  float: left;
  border-radius: 50%;
  margin: 1em 0 0 1em;
  box-shadow: 20px 10px 10px rgba(0, 0, 0, 0.23);
}
/*HACK Width on ".main-container" kind of fixes side scrolling on a desktop viewport since the image was a bit wider than the actual size of my laptop screen was less than 1350px which is the size of the image */
/* HACK Pense en como logre que el .main-container fuera translucido sin usar opacity, evitando asi el stacking context que opacity añade, esto con el objetivo de que sus hijos detras con Z-Index pudieran ser visto. Es posible gracias a background: linear-gradient. */
.main-container {
  /* Papa de todos en la seccion de planetas */
  /* position: relative; */
  /* z-index: 4; */
  background: linear-gradient(
    180deg,
    rgba(187, 119, 154, 0.85),
    rgba(187, 119, 154, 0.65),
    rgba(187, 119, 154, 0.03)
  );
  overflow: hidden;
  height: 110vh;
  width: 100vw;
}
/* NOTE I just tried to uncomment position & Z-Index properties for the div above, .main-container or "the father of them all" to try on it a even lower Z-Index (lower than .upper-main), in order to put the translucid pinky background behind .upper-main and its two children, the problem lies in giving back a stacking context to .main-container which confines all its children and, therefore not allowing the trick of negative values on Z-Index which lets you put children behind parents. */
/*HACK con overflow hidden el texto debajo de esta seccion no se cola al inicio, recuerde q float saca los elementos del flow normal, los elementos siguientes tomarian su lugar, para que overflow hidden sea efectivo se tiene que usar en el papa de los hijos que estan flotando. Acá un link https://www.youtube.com/watch?v=E5ANuFo-Wno  */
/* NOTE Esto explica el primer set de planetas: el porque .upper-main junto a sus hijos quedan detras del papa de toda la seccion .main-container, el cual tiene una transparencia, lo cual deja ver a sus hijos detras: 1- Empezamos con el papa .main-container, que al no estar posicionado se ubica por encima de elementos con Z-Index negativo. 2- Su hijo directo, .upper-main se encuentra posicionado y tambien adquiere stacking context al tener Z-Index diferente a auto, lo cual arrastra a sus hijos con el. 3- Es indiferente si los hijos de .upper-main (.sidebar y .content) tienen stacking context o no, ya que su padre los confina dentro de el al tener stracking context. Como nota si se quisiera que otro elemento se sobreponga a .main-container tendria que ser un elemento hermano de .upper-main, en otras palabras un elemento fuera del stacking context de .upper-main, un elemento que reune esas especificaciones seria ".divfortesting-zindex", .divfortesting-zindex no requiere Z-Index para estar on top of everything else ya que el stacking order default del root HTML, lo posiciona encima de su padre directo .main-container     */
/* Second section, just bellow landpage End First Part*/
/* <<<<<<<<<<<<<<<<<--------------->>>>>>>>>>>>>>>>>>> */
/* Second section, just bellow landpage Start Second Part*/
/* HACK aqui estamos estamos aplicando estilos en cascada a upper-main gracias a una segunda clase para la misma etiqueta, de esta forma me ahorro escribir estilos innecesarios solo sobrescribo los estilos que quiero cambiar como el background color, el resto lo mantengo igual con los estilos de la primer clase en esta etiqueta */
.upper-main-II {
  /* background: rgb(70, 39, 73); */
  background: linear-gradient(
    0deg,
    rgba(70, 39, 73, 1) 24%,
    rgba(131, 50, 172, 1) 51%,
    rgba(224, 134, 211, 1) 77%
  );
  position: static;
}
/*HACK Had to give .upper-main-II above a static position cause it was inheriting position: relative from the 1st .upper-main styles, which was giving it stacking context, as a result it didnt let me put one of .upper-main's children behind it.
/* NOTE Cambiado el angulo de gradient y grandient transition entre 1ra y 2da parte */
.main-container-II {
  /* NOTE cuando el angulo del gradient es 0 el primer color listado en CSS se renderiza abajo de todos en la página web. */
  /* NOTE notese que esta clase fue hecha solo para cambiar la direccion del gradient del .main-container de la 2da parte y que transicione suavemente con el tono transparente con el que termina el .main-container de la 1ra parte.  */
  background: linear-gradient(
    0deg,
    rgba(187, 119, 154, 0.95),
    rgba(187, 119, 154, 0.65),
    rgba(187, 119, 154, 0.03)
  );
  /* position: relative; */
  /* z-index: -1; */
}
/*HACK In line #232 he have another H A C K that explains why the div below, .side-bar-II is behind its direct parent, .upper-main-II. But why does it go beyond and it is also behind .main-container-II? The parent of its parent. The most evident fact as to why that happens is that .main-container-II does not have stacking context, nor directly or indirectly cascading from .main-container from the section #1 of planets. So, when stacking context is added (in this example I decided to use Position+Z-Index to trigger it), the .side-bar-II can not longer be behind .main-container-II, because the parent of the parent has stacking context now. Excepto cuando el valor Z-Index es auto, debido a que asi no aplica stacking context a .main-container-II y por lo tanto .side-bar-II puede escapar y colocarse detras.*/
/*SEARCH Este raro comportamiento relacionado al stacking order/context entre .main-container-II y .side-bar-II puede ser a causa de la cercania de estos dos DIVS con la etiqueta HTML. Por un lado tengo al div de abajo .side-bar-II que tiene un padre directo (.upper-main-II que no tiene stacking context) y un valor de Z-Index de -2, por otro lado tengo al papá del papá (.main-container-II, el cual es papá de .upper-main-II y abuelo de .side-bar-II), que también tiene un Z-Index negativo de -1. Lo raro es que a pesar de tener un valor Z-Index mas alto sigue detrás de .side-bar-II que tiene un valor Z-Index menor de -2. En este escenario, it seems that as long as there is stacking context on .main-container-II the .side-bar-II won't get behind .main-container-II even if it has a lower Z-Index. SO, for the momment I will comment the stacking context triggering properties on .main-container-II (just because I want to have .side-bar-II behind the grandpa). */
.side-bar-II {
  right: 15vw;
  position: relative;
  z-index: -2;
  top: 12vh;
  border: solid 6px red;
}
.content-II {
  position: relative;
  top: 20vh;
  right: 10vh;
}
.divfortesting-zindex-II {
  /* position: relative;
  z-index: 3; */
  background: rgba(187, 119, 154, 0.1);
  height: 65vh;
  width: 70vw;
  float: left;
  border-radius: 50%;
  margin: 2em 0 0 1.8em;
  box-shadow: 15px 10px 10px rgba(0, 0, 0, 0.23);
}
/* Second section, just bellow landpage End Second Part*/
/* <<<<<<<<<<<<<<<<<--------------->>>>>>>>>>>>>>>>>>> */
/* Second section, just bellow landpage Start Third Part*/
.main-container-III {
  background: linear-gradient(
    180deg,
    rgba(187, 119, 154, 0.95),
    rgba(187, 119, 154, 0.65),
    rgba(187, 119, 154, 0.03),
    rgba(255, 255, 255, 1)
  );
  box-shadow: inset 0 -2rem 1rem -1rem #ffcccc,
    inset 0 -14rem 10rem -7rem #ffcccc;
  /* NOTE put this border for a smooth transition between third set of planets and linear strip gradient practice */
}
.divfortesting-zindex-III {
  background-color: aqua;
}
/*SEARCH Podemos ver que .divfortesting-zindex-III está en medio de su hermano .upper-main-III y el planeta rojo (.content-III hijo de .upper-main-III), pero cómo?? Si divfortesting-zindex-III no tiene en ninguna de las 2 clases alguna propiedad que altere su stacking order o que le de stacking context, así que el primer sospechoso fué .content-III (planeta rojo) que  somehow tenia 2 floats, uno en .content-III, el cual comenté, pero el que no quize comentar fue en .content, ya que al comentar ese float provocaba conflictos en el layout de las otras secciones de planetas pasadas. En fin, pude deducir que los elementos flotantes siguen orden de aparición aunque ya no pertenezcan al flow normal del layout, ya que tanto .divfortesting-zindex-III como .content-III se ven afectados por float properties de sus contrapartes mas antiguas en el código (.divfortesting-zindex y .content), asi que flotan pero respetan el orden en el que aparecen en el código de HTML, primero estando .divfortesting-zindex-III y luego .content-III, el papa de .content-III that just happens to be behind there, creates the effect that .divfortesting-zindex-III got between father and son somehow when it actually just occupies the blank space left by its brother .divfortesting-zindex-III that now just hovers over it */
.upper-main-III {
  position: static;
  /* HACK This hack allows to revert what the original styles do (this refers to the 1st .upper-main), with this the original stacking context that .upper-main had was disabled, ya que el value static es valor por defecto que no deja a Z-Index funcionar */
}
.side-bar-III {
  position: relative;
  z-index: -1;
  margin-left: 14vw;
}
.content-III {
  width: 35vw;
  height: 20vh;
  /* float: right; */
  border-radius: 50%;
  background: linear-gradient(
    205deg,
    rgba(131, 58, 180, 1) 0%,
    rgba(253, 29, 29, 1) 50%,
    rgba(252, 176, 69, 1) 100%
  );
  margin: -2rem 1rem 0 0;
  box-shadow: -10px 6px 10px 3px rgba(0, 0, 0, 0.23),
    inset 10px -6px 10px 3px rgba(0, 0, 0, 0.23),
    inset -1px 1px 10px 0.5px rgb(250, 249, 247);
}

/* Second section, just bellow landpage End Third Part*/

/* START map testing */
.secondmaptag {
  display: block;
}
/* NOTE @media below hecho para desaparecer mapped images en dispositivos con dimensiones menores a 350px */
@media only screen and (max-width: 350px) {
  .maptesting {
    display: none;
  }
}
/* End map testing */

/* Start gradient-stripe practice  */
.gradient-background {
  /* background: linear-gradient(90deg, red, yellow, rgb(204, 204, 255)); */
  height: 100vh;
  width: 100vw;
  /* NOTE fixed side scrolling adding full width to the background  */
  padding: 3rem;
  background: linear-gradient(360deg, #ccffff, #ffcccc);
}
.red-stripes {
  /* NOTE Despite having lots of exercices bellow on the animations/transitions section practice, these stripes were the last practice about animations/transitions that I made. First I had altered the stacking context of the red stripes by applying opacity which put them on top of the yellow ones, even though they (red ones) are later on the stacking order of HTML (meaning they are older code in HTML). But then I used Transform on yellow stripes which gave them stacking context too.. what happened then? The yellow stripes got back on top of the red stripes. Why? As soon I used Transform on the yellow stripes they adquired stacking context too so then, the div on top would be decided on which one is later in the HTML code. However, I wanted the red ones on top, I just needed to apply a higher Z-Index value to them. Neither stripe div had position yet so I had to do so first before tinkering Z-Index. Later I used transform along with transition on the red stripes to have a nice effect when hovering or taaping (for mobiles), not that it mattered in regards of stacking order or context because they (red ones) already had oppacity.  */
  position: relative;
  z-index: 2;
  height: 45vh;
  width: 65vw;
  margin: 0 0 0 2.94rem;
  opacity: 0.8;
  /* NOTE recordemos que opacity "con valor menor a 1" nos da stacking context por lo cual las barras rojas se colocan encima de las barras amarillas a pesar de estar situadas antes de las amarillas en el stacking order de HTML root, N O T E S E que las barras amarillas se estan rigiendo por el stacking context de HTML root.  */
  background: repeating-linear-gradient(
    45deg,
    red 0px,
    red 40px,
    black 40px,
    black 80px
  );
  border-radius: 5%;
  transition-property: transform;
  transition-duration: 1000ms;
}

.red-stripes:hover {
  transform: scale(1.4);
}
.yellow-stripes {
  position: relative;
  z-index: 1;
  height: 45vh;
  width: 65vw;
  margin: -4.05rem 2.5rem 0 0;
  /* HACK El truquito de poner las yellow bars debajo lo hace el margin negativo, gracias a que las barras rojas estan en otro stacking context gracias a opacity. */
  border-radius: 5%;
  background: repeating-linear-gradient(
    135deg,
    yellow 0px,
    yellow 40px,
    black 40px,
    black 80px
  );
  transition-property: transform;
  transition-duration: 1000ms;
}
.yellow-stripes:hover {
  transform: scale(1.4);
}
/* End gradient-stripe practice  */
/* <<<<<<<<<<------>>>>>>>>>>> */
/* Making a heart that has a common radial gradient (Transition & Animations Practice) - Start*/
.heart-background {
  height: 60vh;
  width: 100vw;
  /* NOTE had to add width to stop side scrolling */
  background: linear-gradient(180deg, #ccffff, #ffcccc);
  /* padding-top: 5vh; */
}
.square {
  /* HACK Se descubrio que para hacer un gradient con transicion mas suave se pueden crear muchos puntos de transicion con la pagina "https://cssgradient.io/" */
  background: linear-gradient(
    225deg,
    rgba(255, 204, 204, 1) 79%,
    rgba(254, 197, 199, 1) 80%,
    rgba(253, 190, 194, 1) 81%,
    rgba(252, 183, 189, 1) 82%,
    rgba(251, 176, 184, 1) 83%,
    rgba(250, 169, 179, 1) 84%,
    rgba(249, 162, 174, 1) 85%,
    rgba(248, 155, 169, 1) 86%,
    rgba(247, 148, 164, 1) 87%,
    rgba(246, 141, 159, 1) 88%,
    rgba(246, 134, 154, 1) 89%,
    rgba(245, 127, 149, 1) 90%,
    rgba(245, 120, 144, 1) 91%,
    rgba(244, 113, 139, 1) 92%,
    rgba(244, 106, 134, 1) 93%,
    rgba(244, 106, 134, 1) 93%,
    rgba(243, 99, 129, 1) 94%,
    rgba(243, 92, 125, 1) 95%,
    rgba(242, 85, 120, 1) 96%,
    rgba(242, 78, 116, 1) 97%,
    rgba(240, 55, 102, 1) 100%
  );
  width: 31.2vw;
  height: 17.5vh;
  margin: auto;
  /* HACK The only property that pushed the heart down without pushing down its father as well, was top: 15vh, the one bellow, I just didnt want to relay on its parent padding property to push it down, but margin-top would't let me to push it down alone, because it was pushing its parent ".heart-background" as well and created a blank gap between the "heart section" and the stripes section above, as to why that happened, the property "tranform: rotate(-45deg)" and "margin: auto" property had to do with that, first, "margin: auto" helps to center the square by creating equally sized margins to the left and right but then tranform: rotate(-45deg) changes the orientation of the square's margins on both sides while keeping the squAre centered, however that makes the right side margin's top corner point upwards, BEYOND its parent and against the bottom edge of the "stripes section" (TO SEE THIS, USE CHROME DEVTOOLS AND HOVER OVER THIS ELEMENT SO YOU CAN SEE WHERE THE RIGHT SIDE MARGIN POINTS AND HOW THAT ALONG WITH TRANFORM CREATES THE BLANK GAP ON TOP), beyond this point, the wider the right margin is (in this example) the more gap there will be between this section and the stripes section above, so now.. the reason why margin-top was making this blank gap is because the right side margin's top corner will get further as margin right or top increase, therefore the gap gets larger. The other workaround I think is to make the whole heart smaller. */
  top: 15vh;
  transform: rotate(-45deg);
  position: relative;
  /* HACK descubri esta pagina que permite crear sombras facilmente "https://www.cssmatic.com/box-shadow", pero hay muchas opciones de paginas que crean efectos muy ingeniosos */
  -webkit-box-shadow: -25px 25px 9px -19px rgba(0, 0, 0, 0.45);
  -moz-box-shadow: -25px 25px 9px -19px rgba(0, 0, 0, 0.45);
  box-shadow: -25px 25px 9px -19px rgba(0, 0, 0, 0.45);
  animation-name: beat;
  animation-duration: 1500ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0, -0.29, 0.4, 0.5);
}
/* HACK In order to make a 3 dot loading indicator in which the dots move at different pace we need the code that is commented just bellow*/
/* <style>
  .balls {
    border-radius: 50%;
    position: fixed;
    width: 50px;
    height: 50px;
    top: 60%;
    animation-name: jump;
    animation-duration: 2s;
    animation-iteration-count: infinite;
  }
  #red {
    background: red;
    left: 25%;
    animation-timing-function: linear;
  }
  #blue {
    background: blue;
    left: 50%;
    animation-timing-function: ease-out;
  }
  #green {
    background: green;
    left: 75%;
    animation-timing-function: cubic-bezier(1, 1, 2, 2);
  }

  @keyframes jump {
    50% {
      top: 10%;
    }
  }
</style>
<div class="balls" id="red"></div>
<div class="balls" id="blue"></div>
<div class="balls" id="green"></div> */

/* <<<<<<<<<<<<<<<oooooo>>>>>>>>>>>>>>>> */

/* Making the heart beat - Start */
/* HACK When there is a keyframe rule set in the middle of the animation duration (at 50%), it results in two identical animation progressions,one executing towards the 50% and he second towards the end of it. */
@keyframes beat {
  50% {
    /* NOTE con "@keyframes beat" me di cuenta que no se ocupa transform: matrix, siempre y cuando la sintaxis de los values sea correcta, justo como estan los valores de tranform debajo */
    transform: scale(1.4) rotate(-45deg);
  }
}
/* Making the heart beat - End */
.square::before {
  content: "";
  background: #ffcccc;
  width: 30vw;
  height: 17.5vh;
  /* margin-top: -15vh; */
  border-radius: 50%;
  position: absolute;
  transform: rotate(45deg);
  top: -8.5vh;
  left: 0.4vw;
  box-shadow: inset 13px 15px 15px -13px #f03766;
}
/* NOTE Without property content: "";, the pseudo elements ::before or ::after won't show. */
/* NOTE If property content: "" is empty.. every part, including the parent as well as the children "::before & ::after" has to be positioned in order to render (Of course, it needs some other properties in order to show like height and background color), Then, once every part is rendered we can move them around the parent with top, bottom, left and right. If there is something in between the quotation marks like a bullet point E.g, it'll show elements before or after the selected element. */
/* HACK It would've been dificult to place the purple shades over the upper rounded parts of the heart, where I wanted and the way I wanted without transform: rotate().  */
.square::after {
  content: "";
  background: #ffcccc;
  width: 30vw;
  height: 17.5vh;
  border-radius: 50%;
  position: absolute;
  transform: rotate(137deg);
  left: 15.7vw;
  top: 0.08vh;
  box-shadow: inset 11px 12px 15px -12px #f03766;
}

/* Making a heart that has a common radial gradient - End*/

/* Bouncing ball section - transitions & animations - Start  */
.trans-animation {
  width: 100vw;
  height: 150vh;
  background: linear-gradient(0deg, #ccffff, #ffcccc);
  /* perspective: 130px; */
  /* NOTE There is no need for an animation to have a property like perspective (as I had above, in the element to be animated) as a start point from where the animation begins, All animations can have their properties' starting point on the keyframes  */
  /* NOTE There are 2 ways of using perspective, 1st: As a property with a value like the one above, It gives the element visual depth, the smaller the value the greater the visual effect and also activates a 3D space on all direct children. 2nd: As a value or function of the property transform, It gives the element visual depth but at a much lower rate, the smaller the value the greater the visual effect and also activates a 3D space so that other 3D transform values/functions work on the elements targeted by transform. In this case both (.simple-box & .shadow-box) will adquire a 3D space as they are direct children of .trans-animation. (See: https://3dtransforms.desandro.com/perspective) */
  animation-name: perspective;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0.5, 0.05, 1, 0.5);
}
/* HACK Transform-style: preserve-3d was not needed in this Box & Shadow section = There were no children of children needed to make this animation/transition practice or in other words .trans-animation has no grand-children, REMEMBER: Perspective only enables direct children of a given element to be 3D styled. So to fix that there is transform-style: preserve-3d, however in this case it was not needed. */
@keyframes perspective {
  0% {
    perspective: 130px;
  }
  /*NOTE The rules at 0% and 100% for both @keyframes "perspective and not-ok" helped the ball' shadow mimic the behavior that a shadow has when projecting far from the object casting it, at the beginning and the end of the animation. The ball' shadow was intended to start and to end this animation blurred, thanks to the shadow's blur value and the shadow' spread value that further increased the size of the ball' shadow as it is casted from far at the start/end of the animation, in fact, almost half the body' size of the ball' shadow is made with shadow-box property. The perspective property at a low value gives the shadow a strong 3D effect/visual depth at the start/end of the animation, which basically stretches the ball' shadow.  */
  80% {
    perspective: 180px;
  }
  /*NOTE The rules at 80% from both @keyframes "perspective and not-ok" make the ball' shadow look sharper and darker because that is how shadows behave when they approach the object casting them, that effect is thanks to property perspective at a high number which gives the shadow a subtle 3D effect due that the ball' shadow is just below the ball when it touches the "ground" and then, the shadow-box effect helped control the shadow's size, as the ball' shadow got smaller through its course towards the ball, In fact the scale value/function of transform helped to control the size as well. Shadow-box also helped sharpen the shadow's edges as it got closer to the ball. Finally, the ball' shadow darkened due to a higher rate of opacity property at the 80% rule, which is a shadow nature behavior, given the proximity to the object casting it. Then I had to tamper the rotateX value a bit at the 80% rule as the ball' shadow was tilting too much, NOTICE that before messing with rotateX i had the same value "-125deg" for all rules on @keyframe not-ok, however it was tilting too much at the 80% rule which I think It has to do with the visual depth added by perspective. */
  100% {
    perspective: 130px;
  }
}
/*NOTE Using perspective (with a value different from 0 or none) creates a new stacking context.*/

.simple-box {
  width: 34vw;
  height: 20vh;
  background-color: #8332ac;
  margin: 0vh auto 0vh;
  border-radius: 50%;
  animation-name: ok;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0.5, 0.05, 1, 0.5);
  /* NOTE This "@keyframes ok" translates the div vertically (through y-axis) and scales it in different ways. So first, there is a "transform: matrix" property at 0% which changes nothing so it stays the same till it gets to the 80% of the animation within its duration of 1000ms or 1sec, towards the end of the animation the ball turns back to the same position and form.  */
}
/* HACK DO NOT USE "ALL" with transition, cause it hurts the performance */

@keyframes ok {
  0% {
    background-color: #8332ac;
    transform: matrix(1, 0, 0, 1, 0, 0);
  }
  /* NOTE The comma between the x & y axis values is necessary for proper function of matrix transform properties. */
  80% {
    background-color: aquamarine;
    /* transform: translate(0vw, 34vh); */
    transform: matrix(1.3, 0, 0, 0.65, 0, 251);
    /* HACK Found a page that helps with creating 2D transform matrixes. http://angrytools.com/css-generator/transform/ */
  }
  100% {
    transform: matrix(1, 0, 0, 1, 0, 0);
  }
}
.shadow-box {
  opacity: 0.3;
  background-color: rgba(0, 0, 0, 0.55);
  margin: 0vh auto 0vh;
  box-shadow: 2px 2px 11px 34px rgba(0, 0, 0, 0.55);
  width: 24vw;
  height: 13vh;
  border-radius: 50%;
  /* transform: translateY(70vh) rotateY(130deg); */
  /* NOTE There is no need for an animation to have a property like transform (as I had above, in the element to be animated) as a start point from where the animation begins, All animations can have their properties' starting point on the keyframes  */
  animation-name: not-ok;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0.5, 0.05, 1, 0.5);
}
/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXX Start - This is a section dedicated at making triangles XXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
/* HACK The next 5 commented properties bellow make a perfect isosceles trapezoid with borders, the problem is that no shadow-box can render when the element doenst have height, so it will ignore the trapezoid shape made with border tricks. See: https://css-tricks.com/snippets/css/css-triangle/ */
/* border-bottom: 100px solid rgba(0,0,0,0.55); */
/* border-left: 15px solid transparent;
  border-right: 15px solid transparent;
  height: 0;
  width: 44vw; */
/* HACK I continued searching other ways to input the isosceles trapezoid shape bellow the bouncing div, but then I saw this other hack that implies HTML unicode shapes, however I couldn't find an isosceles trapezoid on google, so I had to rely on the perspective property.*/
/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXX End - This is a section dedicated at making triangles XXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
@keyframes not-ok {
  0% {
    opacity: 0.3;
    transform: translateY(70vh) rotateX(-125deg) scale(1);
  }
  80% {
    opacity: 0.6;
    /* HACK Before I tried a negative value on the rotate's X VALUE I was trying 50deg on each rule but I was getting a halo from the .shadow-box's border outwards (which can be tested by adding a border property on .shadow-box or by removing transparency on the shadow-box color), you will see that the shadow takes a good portion of the ball' shadow, I decided to make use of shadow-box properties so that I could toogle the borders sharpeness and control size, but I think that created the halo between the actual body of the ball' shadow and the extended shadow made with shadow-box's property, when I tried a negative value for rotationX the halo dissapeared and what's more I kept the same tilt for the shadow's animation.    */
    transform: translateY(37vh) rotateX(-130deg) scale(1.1, 1.8);
    box-shadow: 2px 2px 2px 18px rgba(1, 0, 3, 0.55);
  }
  100% {
    opacity: 0.3;
    transform: translateY(70vh) rotateX(-125deg) scale(1);
  }
}
/* Cloud section - Start */
/* NOTE This may be within the transition practice section but it works like a splitter from the bouncing ball and the stars. */
/* HACK We can the get the cloud image between the dark and pink linear backgrounds in two ways: 1st: We can put the img tag with class .cloud above the div with class .nightsky so then we can kick the .cloud img tag off the normal HTML flow with the property float, upon that the .nightsky div will follow the normal flow and stick to the pink background above, creating the ilusion the .cloud figure tag is above both linear backgrounds as it is no longer part of the normal flow thanks to the property float. No position property needed in this way. 2nd: We can get the same results without "float" by putting the img tag .cloud inside .nightsky div which has a linear background that renders fine around the img .cloud (child) even though the figure tag .parent (parent) along its child are on top. So why does the linear background of the div .nightsky renders like that despite having two elements on top?  It is due to 3 reasons: a) The format given to the img .cloud (SVG). b) the fact that the parent element with class .parent is transparent due to lack of CSS height or background properties. c) Position: relative given to the img .cloud, which then got placed on the right place thanks to top & left. */
.cloud {
  /* position: absolute; */
  position: relative;
  /* float: left; */
  top: -41.9vh;
  left: -3.597vw;
  margin: 0;
  width: 99vw;
  transform: scale(1.088);
}
/* NOTE It was necessary to apply position and drag up the figcaption so it followed the cloud image. */
figcaption {
  position: relative;
  top: -11vh;
  text-align: center;
  opacity: 0.5;
  color: white;
}
.nightsky {
  /* position: relative; */
  width: 100vw;
  height: 175vh;
  background: linear-gradient(black, #000099, #66c2ff, #ffcccc, #ffeee6);
}
.stars {
  position: relative;
  width: 7vw;
  height: 4vh;
  border-radius: 50%;
  background-color: aliceblue;
  clip-path: polygon(
    51% 18%,
    58% 40%,
    79% 46%,
    59% 56%,
    51% 78%,
    42% 56%,
    22% 47%,
    43% 40%
  );
}
.star-one {
  top: 28%;
  left: 85%;
  animation-name: blink-one;
  animation-duration: 2000ms;
  animation-iteration-count: infinite;
  transform: scale(0.7);
  opacity: 0.5;
}
@keyframes blink-one {
  50% {
    transform: scale(1.7);
    opacity: 1;
  }
}
.star-two {
  top: 40%;
  left: 40%;
  animation-name: blink-two;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  opacity: 0.7;
}
@keyframes blink-two {
  50% {
    transform: scale(1.2);
    opacity: 1;
  }
}
.star-three {
  top: 25%;
  left: 20%;
  animation-name: blink-three;
  animation-duration: 1000ms;
  animation-iteration-count: infinite;
  animation-timing-function: cubic-bezier(0, -0.29, 0.4, 0.5);
  opacity: 0.9;
}
@keyframes blink-three {
  50% {
    transform: scale(1.3);
    opacity: 1;
  }
}
.star-black {
  top: 55vh;
  left: 75vw;
  background-color: black;
  animation-name: black-star;
  animation-duration: 3000ms;
  animation-iteration-count: infinite;
  transform: scale(0.85);
}
@keyframes black-star {
  50% {
    transform: scale(1.4);
  }
}
/* Cloud section - End */
/* Here I practice transitions & animations - End  */
/* --------------------------------------------------------------------------------------------------- */
/* Audio and Video Sections - Start */

.video-audio-test {
  width: 100vw;
  height: 110vh;
  /* HACK I had an issue that was fixed by giving this father element (.video-audio-test) a value of 110vh (viewport height) for the height attribute. Prior to this value it only had 100vh to cover the 10vh I had given its 1st child element named .Ridiculous (the audio) and 100vh given to its second child element named .amorgatino (the vidoe), making the second child overlap its father, lacking height. Resulting on the video covering the upper section of the form. */
  background-color: #f1f3f4;
  box-shadow: 0 -2rem 1rem 0.5rem #f1f3f4;
}
/* Audio section -Start */
/* NOTE Styling the audio menu without JavaScript seems not possible, so I had to work around it by using Color Picker to copy the greyish color of the audio menu and added it as background to the father above ".video-audio-test" so the audio menu seems like it has no edges. Then added shadow to the father ".video-audio-test" which is casted upwards and gracefully fades into the upper div's background color. */
.ridiculous {
  display: block;
  margin: auto;
  height: 10vh;
}
/* Audio section - End */
/* Video section - Start */
.amorgatino {
  width: 100vw;
  height: 100vh;
  margin: auto;
}
/* Text track (Captions) Start */
::cue {
  background-color: rgb(250, 249, 247, 0.3);
  color: black;
  font-weight: bold;
  line-height: 1.4em;
}
/* Text track (Captions) End */

/* Video section - End */
/* Audio and Video Sections - End */
/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
/* Forms sections || Start */

h2 {
  padding: 1em 0 0 0;
  font-size: 2em;
  letter-spacing: .2rem;
  /* NOTE Chrome added bold to this element with the user agent stylesheet (check with chrome developer tools). */
}

.subscribe_legend {
  display: none;
  /* NOTE this removed the border and text from the HTML element */
}

/* Radio input section - Start */

.radio_inputs_divfather {
  padding: 1.5em 1.5em 2em;
}

.radio {
  /* NOTE This is the label or text for the radio input/s*/
  align-items: flex-start;
  display: inline-flex;
  /* NOTE These 2 properties above need to be applied to this label element, which is the father wrapping the children so they(the custom radio button and the actual radio button that is hidden) are bunched and (regardless of their display type, even block elements) repositioned together with the property align-items property, through the cross axis (vertically).   */
  cursor: pointer;
  font-size: 1.25rem;
  margin-top: .6em;
  /* height: 4em; */
  /* border: 2px solid red; */
  /* NOTE The height and border properties commented above helped to easily visualize that the property align-items: center can reposition every element within the label but there was gap below the text (only visible after adding height) due to the line-height property (applied by default by the browser) that was not allowing a have perfect height simetry with its other siblings (the custom radio button and the actual radio button that was hidden). */
  /* NOTE Remember that height can't be applied to a label element which is by default inline, but thanks to the property display: inline-flex you can, and also enables you to move its children with properties like align-items. */
  line-height: 33px;
  /* NOTE The property line-height helps to further position the text vertically inside the label by either increasing or decreasing its browser's defaults. Basically, this property wraps the text inside a "line box" that acts like padding over the x-height which is an imaginary line just above every lower case (excluding letters like: l, h, t, f, etc) and below the baseline, which is an imaginary line below ALL letters (excluding letters like j, g, p, y). So, if you have a value of 10px for the property line-height, 5px will apply above the x-height and 5px below the baseline. See more at: https://css-tricks.com/how-to-tame-line-height-in-css/  */
  /* SEARCH By the way, the default line height value that every label/text had in chrome was 24.6px but increasing it to 27px helped to center the text for each label, I just dont get why increasing the value would pushed the labels down.. */
}

.radio_input {
  /* NOTE This is the actual radio input */
  display: none;
}

/* Custom input styles for coritO || START */
.radio_ball_corito {
  /* NOTE This is the gray circle. */
  height: 1.25em;
  width: 1.25em;
  border: 2px solid #d8e4e2;
  border-radius: 50%;
  padding: 2px;
  margin-right: .3em;
  /* NOTE The property commented below was already applied to the whole body so we dont need it here. Its function is to keep the same element size, regardless of either how much padding there is against the elements inside (in this case, the pseudo-element just below) or margin agaisnt its inner edge. */
}

.radio_ball_corito::after {
  /* NOTE This is the colored ball inside the gray circle. */
  content: "";
  width: 100%;
  height: 100%;
  display: block;
  background-color: #0f40e0;
  border-radius: 50%;
  /* NOTE These 5 properties above render a colored ball which along the custom radio input just above conform the custom radio input.  */
  /* NOTE I had to apply transform: scale(0) below to visually hide the colored ball by default. */
  transform: scale(0);
  transition: .4s;
}

.radio_input:checked + .radio_ball_corito::after {
  /* NOTE This adjacent sibling combinator/selector and the property transform is what renders the colored ball inside the gray circle when clicking it or the label. This is all thanks to the label that is wrapping the gray circle (custom radio button) and the actual input (hidden) so, no matter where you click on (the gray circle or the label) you will click the label; therefore, you will trigger/check the actual radio button input that is hidden because the radio input and the label are linked through the ID. You can read this element like this: Apply transform: scale(1) to the element named .radio_ball::after that was VISUALLY hidden with transform: scale(0) IF the radio input (COMPLETEDLY hidden) is checked.*/
  transform: scale(1);
}
/* Custom input styles for coritO || END */


/* Custom input styles for coritA || START */
.radio_ball_corita {
  /* NOTE This is the gray circle. */
  height: 1.25em;
  width: 1.25em;
  border: 2px solid #d8e4e2;
  border-radius: 50%;
  padding: 2px;
  margin-right: .3em;
  /* NOTE The property commented below was already applied to the whole body so we dont need it here. Its function is to keep the same element size, regardless of either how much padding there is against the elements inside (in this case, the pseudo-element just below) or margin agaisnt its inner edge. */
}

.radio_ball_corita::after {
  /* NOTE This is the colored ball inside the gray circle. */
  content: "";
  width: 100%;
  height: 100%;
  display: block;
  background-color: #e262a2;
  border-radius: 50%;
  /* NOTE These 5 properties above render a colored ball which along the custom radio input just above conform the custom radio input.  */
  /* NOTE I had to apply transform: scale(0) below to visually hide the colored ball by default. */
  transform: scale(0);
  transition: .4s;
}

.radio_input:checked + .radio_ball_corita::after {
  /* NOTE This adjacent sibling combinator/selector and the property transform is what renders the colored ball inside the gray circle when clicking it or the label. This is all thanks to the label that is wrapping the gray circle (custom radio button) and the actual input (hidden) so, no matter where you click on (the gray circle or the label) you will click the label; therefore, you will trigger/check the actual radio button input that is hidden because the radio input and the label are linked through the ID. You can read this element like this: Apply transform: scale(1) to the element named .radio_ball::after that was VISUALLY hidden with transform: scale(0) IF the radio input (COMPLETEDLY hidden) is checked.*/
  transform: scale(1);
}
/* Custom input styles for coritA || END */

/* Custom input styles for BOTH || START */
.radio_ball_both {
  /* NOTE This is the gray circle. */
  height: 1.25em;
  width: 1.25em;
  border: 2px solid #d8e4e2;
  border-radius: 50%;
  padding: 2px;
  margin-right: .3em;
  /* NOTE The property commented below was already applied to the whole body so we dont need it here. Its function is to keep the same element size, regardless of either how much padding there is against the elements inside (in this case, the pseudo-element just below) or margin agaisnt its inner edge. */
}

.radio_ball_both::after {
  /* NOTE This is the colored ball inside the gray circle. */
  content: "";
  width: 100%;
  height: 100%;
  display: block;
  background-color: #6c11d3;
  border-radius: 50%;
  /* NOTE These 5 properties above render a colored ball which along the custom radio input just above conform the custom radio input.  */
  /* NOTE I had to apply transform: scale(0) below to visually hide the colored ball by default. */
  transform: scale(0);
  transition: .4s;
}

.radio_input:checked + .radio_ball_both::after {
  /* NOTE This adjacent sibling combinator/selector and the property transform is what renders the colored ball inside the gray circle when clicking it or the label. This is all thanks to the label that is wrapping the gray circle (custom radio button) and the actual input (hidden) so, no matter where you click on (the gray circle or the label) you will click the label; therefore, you will trigger/check the actual radio button input that is hidden because the radio input and the label are linked through the ID. You can read this element like this: Apply transform: scale(1) to the element named .radio_ball::after that was VISUALLY hidden with transform: scale(0) IF the radio input (COMPLETEDLY hidden) is checked.*/
  transform: scale(1);
}
/* Custom input styles for BOTH || END */


/* HACK The text that is now between span tags was initially between the label tags when I wanted to target it when the radio input  " .radio_input" was checked. The problem I kept facing was the lack of parent selector in CSS for the non-obvious relationship between the text that was between the label tags and the radio input so, despite the hierarchy looked the same for both (and the custom input between them), the text was another part of the label tag which is the father surrounding the input siblings, meaning that a general sibling selector like  .radio_input:checked ~ label was not targetting the text below the input (when checked) as it was not a sibling until it was wrapped between the span tags. Ideally you'd achieved this without interacting with the markup as I did here because in the real world you may not always have access to the HTML file; however, Javascript is needed to workaround this and I knew nothing about it at the time of making these notes. */
.radio_input:checked ~ span {
  font-weight: bold;
  /* NOTE BTW this selector will just apply bold text to the label text of the radio input checked. */
}

.radio:nth-child(-n+3) {
  /* HACK This selector follows the pattern indicated by the formula within the parenthesis to apply the property margin to siblings or elements with the same hierarchy level that share the same class .radio. For this example the formula picks up the first two elements. */
  /* NOTE The element selection logic used by the :nth-child pseudo-selector is based on the relationship between the targeted element/s with their parent and siblings. There is a couple of ways to construct the expresion or formula inside the parenthesis of the :nth-child selector. However, there are 2 no-brainer keywords that you can input instead. First, (even) that selects even numbered elements like 2, 4, 6, etc. Then, (odd) that selects odd numbered elements like 1, 3, 5, etc. For more complex element selection you'll need to use formulas or expresions; however, you may want to know how they work so here is the most basic expresion: (3), which would only select the third element with the class of .radio (in this example). Then, going a bit further you can go like this (2n+1) which is the same as (odd) because you'd be selecting every other element, starting with the first element. The trick is understanding the “n” and the algebraic expression that it represents every time the formula is executed by the browser and thus, the selection/style application to every element matching the formula's pattern and the simple selector like the class selector in this case (.radio), until there are no more elements to select. So, when the formula (for example 2n+1) is executed for the first time, the "n" would equal zero and the first coefficient (2) would multiply it, so what the browser would actually execute the 1st time would be this (2*0)+1= 1 because (2*0)= 0 + 1= 1 which in turn selects the 1st matching element, meaning that the second coefficient (1) determines where the :nth-child selector begins. The variable "n" would become 1 the next time the expresion (2n+1) gets executed by the browser, meaning the expresion would change to (2*1)+1= 3, selecting the third matching element and thus, creating a selection pattern every other element starting from the 1st matching element. Here is another example (2n+2) which 2nd coefficient has a value of 2, which is the same as using (even) or (2n) within the parenthesis, because an expresion like (2n or 2*0) equals zero on the first execution and would select nothing as there is no 0th element; however, on the second execution the value of the variable "n" becomes 1 and the expresion returns 2 because (2*1)= 2, selecting the 2nd matching element and then starting the selection pattern every other element with a third execution that selects a 4th matching element as the variable "n" goes up again (2*2)= 4. You're not forced to use a positive operator on every expresion as you can also use a negative operator which again points out the 2nd coefficient's function to determine where the pattern begins as you'll see with this expresion (3n-2) which returns -2 because (3*0)= 0 + -2= -2 which does nothing as a -2th element doesn't exit, the first matching element selection will happen only after the 2nd execution as the "n" becomes 1, returning a value of 1 because (3*1)= 3 -2= 1 and the next expresion execution would return a value of 4 because (3*2)= 3 -2= 4 which creates a selection pattern every 3 elements, starting with the 1st one.                                                                       The first coefficient can be negative, which reverts the selection pattern that by default is based on source order (first the older elements above and then the newer ones below), meaning the selection pattern would go "upwards" per say (first the newer elements below then the older ones above); for example, upon the first execution, this expresion (-n+3 OR -1n+3) would select the third matching element thanks to the 2nd coefficient because -1*0= 0 + 3= 3 and then, upon the 2nd execution it would select the 2nd matching element because -1*1= -1 + 3= 2, creating a selection pattern to every single element before/above on a third execution onwards. The take-away of expresions with a first coefficient equal to -1 is the selection range created from the first matching element determined by the second coefficient to all prior matching element above. Remember, there is always a value of 1 when the variable "n" is alone as you see in this last example (-n+3) and also remember the result would always be negative when there is a multiplication between a positive and a negative factor. Finally, the last example (-2n+4) also has a negative first coefficient to revert the selection patterns; however, this time, the 4th matching element would be selected first because -2*0= 0 + 4= 4 and then, since the variable "n" goes up to 1 the second matching element is selected upon the 2nd execution because -2*1= -2 + 4= 2, creating a selection pattern every other element before/above it but, since there are no more matching elements to select before/above the 2nd one it stops there. */
  /* HACK It's important to point that the expression execution or counting of the pseudo-selector (:nth-child) doesn't change when adding a new sibling because it is generic and counts every child/sibling present; however, the styling may vary if the new element/s added don't match the simple selector (in this case class .radio) preceding the pseudo-selector :nth-child(-n+2) so, In this there was a change upon adding the h2 above the label tags; however, the selector still styled the 2nd element which has the class .radio but didnt do the same for the 1st element (h2) now as it did before because it doens't have the class .radio. So, to fix this I had to increase the second coefficient of the expression from 2 to 3 (-n+3) so the second label tag with class .radio also got styled which became the third sibling element upon adding the h2 tag; therefore, it wouldn't get targeted by the previous expression (-n+2).  */
  margin-right:.7em;
}

/* Email input section - Start */
.label_email {
  display: block;
  /* NOTE display:block made the label be on top of the input field */
  padding: .5em 0 0 0;
  font-size: 2em;
  font-weight: bold;
  letter-spacing: .2rem;
}

.email_divfather {
  width: 90vw;
  margin: auto;
  padding: .75em .75em 1.5em;
  border-top: solid .1em black;
}

.email {
  padding: .15em;
  width: 100%;
  height: 2em;
  font-size: 1.25rem
}

.submit {
  margin: .05em 0 0 0;
  padding: .15em;
  width: 100%;
  height: 2em;
  font-size: 1.25rem;
  background-color: #0f40e0;
  color: white;
  font-weight: bold;
  letter-spacing: .2rem;
  border: solid .1em black;
  border-radius: 3%;
}

fieldset {
  height: 90vh;
}
/* Email input section - END */

/* Flexbox section - Start */

.primer_grupo {
  display: flex;
  background-color: lightblue;
  height: 100vh;
}

/* NOTE By default, the "flex items" or direct children of a container with display:flex or "flex container" stack from left to right as they have a row or horizontal orientation, which can be changed with the flex-direction:column property so they stack from top to bottom. Both, row and column flex items have a main axis and a cross axis through which they can be moved. The main axis for row flex items is an imaginary line going through them, from left to right. For column flex items, the main axis is an imaginary line crossing them, from top to bottom. So, depending of the flex items direction you can move them through their main axis with the property justify-content; whether that is horizontally or vertically. Then, you have the cross axis which is another imaginary line that is perpendicular to the main axis that crosses the column flex items from left to right and the row flex items from top to bottom. So, depending of the flex items direction you can move them through their cross axis with the property align-items, whether that is horizontally or vertically. The default value for the align-items property is "stretch" meaning that row flex items get vertically stretched over their cross axis to fill whatever height their flex container (parent) has and the column flex items get their width stretched across their cross axis to fill whatever width their flex container has (parent); however, this stretching over the cross axis can be overridden for both directions, when the width value for column flex items is other than "auto" or when the height property value for row flex items is other than "auto", which is the default value when you DON'T specify any value for an element's width or the height so the elements size is based on the content. In other words, the stretching over the cross axis is overridden by flex items aiming their cross axis with height or width property values different to "auto". Also, when the flex item/s value for height or width that aims the cross axis is equal to "auto" and the value for align-items or align-content (which I'll explain later) is different to stretch, the cross size of each flex item would tighly surround its content IF THERE IS ANY; otherwise the flex item would be invisible (Assuming the flex item/s width or height is also set to "auto" throughout the main axis). Another way to override the stretch value of align-items is by using another property called "align-self" which is meant to be used on the flex items, not the flex container like align-items. Align-self only targets the position of the flex item you apply it to and it can use the same values than align-items. For the past 16 or 17 lines above I've talked about the properties that affect the cross axis and its cross size but now I'll retake and further the main axis description started on the first 4-5 lines of this note. There is another property exclusive for flex items called flex-basis that determines their BASE size over the main axis, meaning that it can change the size for both, HEIGHT: if flex-direction's value is column or WIDTH: if flex-direction's value is row. You can still use the old width or height for sizing flex items over the main axis; however, in this flexbox section I'll use flex-basis for the main axis. Whether sizing is done with flex-basis or not, the flex items' base size may vary thanks to 2 properties and their default values that both flex container and flex items have. <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<For the examples's sake you'll assume the flex container has an absolute measure unit for its main size (not responsive), so the base size of each flex item over the main axis wouldn't change unless their full-extent (including margin and border) is above the flex container's dimensions (including padding), causing every flex item to equally shrink over the main axis due to the default value of flex-shrink which is 1 on every flex item. If the full-extent of the flex items (including margin and border) is below the flex container's dimensions (including padding) you may want to stretch the extent of every flex item to fill the gap by changing the default value of flex-grow, from 0 to 1 to equally spread the extent of every flex item throughout the remaining blank room of the main axis. It's worth noticing that both flex-shrink and flex-grow are meant to be used on the flex items not the flex container and also that both properties can lock the flex items' growth or shrinking when their values are zero or kind of the opposite when boosting their growth or shrinking of some flex items more than others by upping their values above 1. Therefore, these 2 properties only stretch or shrink the flex items equally over the main axis when their values are 1. <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<Now I'll explain how the flex-grow property figures how to stretch every flex-item based on the remaining blank space over the main axis. So, for this example suppose there are 4 flex-items (including margin and border) that only took 400px out of 500px from the flex container (including padding), meaning the blank space is 100px. If they all had a growth factor of 1 "flex-grow:1" every flex item would share the blank space equally and grow 25px; however, in this example there are 3 flex items with a growth factor of 1 and the other one has a growth factor of 2, meaning the flex item with growth factor of 2 would multiply twice with the growth unit (20px) which is the result of dividing the blank space (100px) between whatever number comes upon summing the growth factor of each flex item (5). To sum up, the flex item with growth factor of 2 would grow 40px out of the 100px in blank, leaving 60px to be taken for the 3 remaining flex items with a growth factor of 1. The equation for flex-shrink is the same that flex-grow; however, for flex-shrink to kick in, the full-extent of the flex items has to surpass the flex container's dimensions. The flex container's dimension is again 500px (including padding) but the full-extent of the SAME (4) flex items is now 800px (including margin and border), meaning there is a 300px surplus. If they all had a shrink factor of 1 "flex-shrink:1" every flex item would squish into the flex container with the same size, losing 75px as you can't fit 4 elements of 200px within a 500px container; however, in this example there are 3 flex items with a shrink factor of 1 and the other one has a shrink factor of 2, meaning the flex item with shrink factor of 2 would multiply twice with the shrink unit (60px) which is the result of dividing the surplus (300px) between whatever number comes upon summing the shrink factor of each flex item (5). To sum up, the 300px surplus will be deducted from the size of each flex item so, the flex item with shrink factor of 2 would shrink 120px, leaving a 180px surplus to deduct from the 3 remaining flex items with a shrink factor of 1.  */

/* NOTE There is another property exclusive for flex items and it's a shorthand for the 3 sizing properties, it's called "Flex" and its default is "flex: 0 1 auto" where "zero" represents the default of flex-grow, the number "one" is flex-shrink's default and "auto" the default for flex-basis; however, if you were to change the defaults it's not mandatory to specify the 3 values, you can get away with the 1st value for flex grow (using unitless integers) and omit the 2nd and 3rd values as long as you remember that omitting the 2nd value (flex-shrink) wouldn't change its default but omitting the 3rd value (flex-basis) turns its default (auto) into "zero" so the flex items's sizing becomes ABSOLUTE instead of RELATIVE to their content's size. When flex-basis is 0, flex-grow ignores the size of the content within the flex items and equally splits the main size across the main axis between the number of flex items, assuming the growth factor was 1 on every flex item but of course you can set the growth factor higher for some flex items so they're not slit equally but the sizing is based on the growth factor; however, depending on how large the content is, there is a limit to how small a flex item can be along the main axis, due to the default values of 2 properties: min-width:auto & min-height:auto, they both set the items to not shrink past the content size unless you change them to min-width:0 OR min-height:0 OR overflow:hidden (or any other value, except visible). This workaround should work unless the flex container is also a flex item too, in that case just override the min-width and min-height defaults.   */
/* TODO LISTAR TODAS LAS FORMAS EN QUE SE PUEDE SETEAR FLEX Y SUS IMPLICACIONES, TAMBIEN MENCIONAR QUE SE PUEDE USAR EL PRIMER VALUE DE FLEX CON ALGUNA UNIDAD DE MEDIDA O PORCENTUAL, LO CUAL OMITIRÍA LOS PRIMEROS DOS VALORES DE FLEX-GROW Y FLEX-SHRINK Y QUEDARÍAN SUS VALORES POR DEFECTO. */
/* HACK Ejemplo de flex item content puede ser una letra o palabra dentro y nada tiene que ver con padding or sizing mediante absolute unit or percentage units texto dentro de algún tag  */
/* HACK flex: auto is the same as flex: 1 1 auto */
/* HACK If you have a FLEX: 0 0 100PX; you are setting flex item/s (including margin and border) that don't grow, don't shrink and stay fixed at 100px */
/* NOTE It's worth mentioning that the values for flex-grow and flex-shrink only take unitless integers */
/* NOTE It's worth mentioning that the properties width or height can override flex-basis:auto but not flex-basis with a value of 0 or any other absolute or percentage size value. */
/* NOTE It's worth mentioning that "flex: auto" is not the same as the default values of flex, because it breaks down to "flex: 1 1 auto". */
/* TODO mencionar que align-items is for flex items wrapped en una sola fila y align-content for 2 o mas filas de flex items, creo que acá entra el FLEX-WRAP QUE TAMBIÉN TENGO QUE MENCIONAR. */
/* HACK Every time a flex container has plain text as direct child it wraps the text with an invisible tag so it becomes a flex item. */

.parrafo:nth-child(1) {
  background-color: red;
 }

 .parrafo:nth-child(2) {
  background-color: green;
 }

 .parrafo:nth-child(3) {
  background-color: blue;
 }

 .parrafo {
  font-size: 3rem;
  color:aliceblue;
  font-weight: bold;
  flex: 1;

  /* overflow: hidden; */
  /* min-width: 0; */
  /* min-height: 0; */
 }


/* Flexbox section - END */
